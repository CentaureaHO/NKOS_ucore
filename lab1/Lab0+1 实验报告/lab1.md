# Lab 1实验报告
### 练习1：理解内核启动中的程序入口操作
阅读 `kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？ `tail kern_init` 完成了什么操作，目的是什么

答：
1. `la sp,bootstacktop` 指令的功能是：将`bootstacktop`的地址加载到`sp`寄存器中，而`sp`寄存器是栈指针寄存器，其指向栈顶的地址，将`bootstacktop`加载到`sp`寄存器中，而后它将指向`bootstacktop`对应的地址。
   
2. 这个操作的目的：将`OpenSBI`对应的物理地址加载给`sp`寄存器，从而进行`OpenSBI`的操作，将操作系统加载到内核当中，从而实现操作系统的调用。
3. `tail kern_init`：主要是实现了尾调用，当执行完前面的指令后，通过尾调用执行`kern_init`中的指令，实现了指令的跳转
4. `tail kern_init`的目的：当执行完`la sp,bootstacktop` 指令之后，不用返回，直接通过尾调用进入`kern_init`的指令中，执行相关的指令，也就是直接执行初始化的代码，这有利于提高代码的执行效率。

### 练习2：完善中断处理 （需要编程）
请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。
要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

答：
根据实验指导书的相关内容：我们发现，当出现中断的时候，操作系统会经过各个步骤的处理，最后在trap.c文件中将进行异常的相关处理，因此我们如果想要实现相关功能，就需要在trap.c文件中的interrupt_handler函数下进行相关功能的实现。如下图所示：
[img\图片1.png]()

我们通过调用sbi中相应的时钟函数，从而继续计数，当我们打印次数为10之后，会调用sbi_shutdown()将系统关闭。下面是运行的结果：
[img\图片2.png]()


### 扩展练习 Challenge1：描述与理解中断流程
回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

答：
- **描述ucore中处理中断异常的流程：**
1. 异常的产生：中断和异常的产生都是由于在程序执行过程中遇到了某些事件（例如：外部硬件出发的中断，内部程序执行过程中出现的异常），此时处理器会产生一个异常；
2. 异常处理程序的介入：异常出现后首先进入异常处理程序，通过_alltraps标签进入对应的处理部位进行处理
3. 保存当前的状态，在进入异常处理函数之后，首先调用SAVE_ALL,保存当前的所有寄存器的值，同时还会额外存储四个寄存器，sstatus,sepc,sbadaddr,scause，它们四个寄存器分别保存了异常发生的时候的当前状态，为后续的异常处理提供方便，而后jal trap进入异常处理程序之中；
4. 处理异常，异常处理函数的核心是在trap中，其中分为了interrupt_handler和exception_handler，分为多种情况，有各自的处理方式。
5. 恢复：当完成了相应的异常处理之后，程序需要恢复原来的状态，调用RESTORE_ALL，此时跟之前保存类似，除了恢复这些通用寄存器的值之外，我们还需要将之前的异常时的四个寄存器也恢复，但是我们只回复sstatus和sepc两个寄存器中的值，对于另外两个则不会恢复。最后返回用户模式，即完成了相关的内容。
-  **mov a0,sp的作用**，将sp栈指针赋值给a0寄存器，这样a0寄存器中的值可以作为后续函数执行的参数，在调用trap函数处理的时候，将相关的程序执行信息传递给函数，从而保证trap函数执行功能时的正常运行。
- **SAVE_ALL中寄寄存器保存在栈中的位置的确定**:可以通过一个固定的偏移量进行确定，如图所示：
[img\图片3.png]()
代码中为每一个寄存器都编了一个号，我们可以通过编号*偏移量（REGBYTES）来进行存储。同时与异常处理相关的四个寄存器也按照这种方式进行存储。
- **对于任何中断，__alltraps 中都需要保存所有寄存器**，这样是为了保存所有在异常发生的过程中出现的异常信息，为了在异常处理程序中可以接受所有的信息并进行相关的异常处理，但是在异常处理结束之后，不需要还原所有的寄存器的值，例如异常处理寄存器。


### 扩展练习 Challenge2：理解上下文切换机制
回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

答：
1. **csrw sscratch, sp的操作与功能：**
csrw指令的操作主要是将sp寄存器的值写入sscratch寄存器中，该指令主要是在在中断处理的过程中，将目前的sp进行存入sscratch寄存器下，这样做的目的是在中断发生时，为了保护堆栈的指针创建的临时存储空间
2. **csrrw s0, sscratch, x0的操作和功能:**
这条指令的作用是将sscratch的值存入s0中，而后把x0的值存入sscratch寄存器中，这样可以将原本的sscratch寄存器中的值存入s0后，将x0存入原来的sscratch寄存器中。这样可以保护原来sscratch中的信息，同时，由于x0寄存器是零寄存器，因此我们可以保证在后续的操作不会覆盖原来的值，保证后续的异常程序的正常执行和恢复。
3. **store的意义：**
我们在异常程序执行的过程中，使用store将四个异常处理相关的寄存器进行存储，但是在restore all中，我们只需要还原sstatus和sepc两个寄存器，而sacuse和sbadaddr则不会被恢复。要回答这个问题，我们需要了解这四个与异常有关的寄存器的作用：

`status`寄存器负责保存当前的CPU运行状态

`sepc`保存出发中断或者异常的有关指令

`sbadaddr`保存了出现异常的地址

`scause`则存储了异常或者发生中断的原因

我们在恢复的时候，已经解决了程序的中断和异常的处理，因此不需要保存异常出现的地址和出现中断或者异常的原因。只需要恢复必要的寄存器就行，这样可以确保异常处理后程序的运行。


### 扩展练习Challenge3：完善异常中断
编程完善在触发一条非法指令异常 `mret`和，在 `kern/trap/trap.c`的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即`“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”`与`“Exception type:Illegal instruction"，“Exception type: breakpoint”`。

答：
由于非法指令异常与中断是`trap`中处理的两种不同情况，因此我们需要在`trap.c`文件中，修改`exception_handler`函数使其能够完成相关的功能，代码的修改如下所示：
[img\图片4.png]()
需要特别强调的是，`ebreak`指令只有两个字节，所以在完成断点的异常处理之后，只需要`pc+=2`，就可完成指令的跳转，如果`pc+=4`,则会出现程序跳转错误的情况。

如下所示为编写的代码部分，主要用来进行异常的类型判断和指令的触发。

下面我们运行程序并进行相关的测试，根据理论知识可知，我们的中断处理程序可以在各种情况下进行中断处理，例如：我们可以在init.c文件中插入ebreak和mret指令来检验中断程序
[img\图片5.png]()
同样的，我们可以在clock.c文件中插入相关的ebreak和mret指令进行中断的检测。
[img\图片6.png]()
最终得出的结果如下所示：
[img\图片7.png]()
首先ucore会跳转到相关的异常处理函数，输出对应的异常类型和发生错误的指令地址，而后跳转回原来的状态，回到中断处理状态，而后经过10次100ticks的打印之后，就会调用sbi.h中的shut_down()函数关机。